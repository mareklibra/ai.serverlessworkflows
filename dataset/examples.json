[
  {
    "input": "This example shows a single Operation State with one\naction that calls the “greeting” function. The workflow data input is\nassumed to be the name of the person to greet:",
    "output": "{\n\"id\": \"greeting\",\n\"version\": \"1.0\",\n\"specVersion\": \"0.8\",\n\"name\": \"Greeting Workflow\",\n\"description\": \"Greet Someone\",\n\"start\": \"Greet\",\n\"functions\": [\n  {\n     \"name\": \"greetingFunction\",\n     \"operation\": \"file://myapis/greetingapis.json#greeting\"\n  }\n],\n\"states\":[\n  {\n     \"name\":\"Greet\",\n     \"type\":\"operation\",\n     \"actions\":[\n        {\n           \"functionRef\": {\n              \"refName\": \"greetingFunction\",\n              \"arguments\": {\n                \"name\": \"${ .person.name }\"\n              }\n           },\n           \"actionDataFilter\": {\n              \"results\": \"${ .greeting }\"\n           }\n        }\n     ],\n     \"end\": true\n  }\n]\n}"
  },
  {
    "input": "This example shows a single Event State with one action\nthat calls the “greeting” function. The event state consumes cloud\nevents of type “greetingEventType”. When an even with this type is\nconsumed, the Event state performs a single action that calls the\ndefined “greeting” function.",
    "output": "{\n\"id\": \"eventbasedgreeting\",\n\"version\": \"1.0\",\n\"specVersion\": \"0.8\",\n\"name\": \"Event Based Greeting Workflow\",\n\"description\": \"Event Based Greeting\",\n\"start\": \"Greet\",\n\"events\": [\n {\n  \"name\": \"GreetingEvent\",\n  \"type\": \"greetingEventType\",\n  \"source\": \"greetingEventSource\"\n }\n],\n\"functions\": [\n  {\n     \"name\": \"greetingFunction\",\n     \"operation\": \"file://myapis/greetingapis.json#greeting\"\n  }\n],\n\"states\":[\n  {\n     \"name\":\"Greet\",\n     \"type\":\"event\",\n     \"onEvents\": [{\n         \"eventRefs\": [\"GreetingEvent\"],\n         \"eventDataFilter\": {\n            \"data\": \"${ .greet }\",\n            \"toStateData\": \"${ .greet }\"\n         },\n         \"actions\":[\n            {\n               \"functionRef\": {\n                  \"refName\": \"greetingFunction\",\n                  \"arguments\": {\n                    \"name\": \"${ .greet.name }\"\n                  }\n               }\n            }\n         ]\n     }],\n     \"stateDataFilter\": {\n        \"output\": \"${ .payload.greeting }\"\n     },\n     \"end\": true\n  }\n]\n}"
  },
  {
    "input": "In this example we show how to iterate over data using the ForEach State. The state\nwill iterate over a collection of simple math expressions which are\npassed in as the workflow data input:",
    "output": "{\n\"id\": \"solvemathproblems\",\n\"version\": \"1.0\",\n\"specVersion\": \"0.8\",\n\"name\": \"Solve Math Problems Workflow\",\n\"description\": \"Solve math problems\",\n\"start\": \"Solve\",\n\"functions\": [\n{\n  \"name\": \"solveMathExpressionFunction\",\n  \"operation\": \"http://myapis.org/mapthapis.json#solveExpression\"\n}\n],\n\"states\":[\n{\n \"name\":\"Solve\",\n \"type\":\"foreach\",\n \"inputCollection\": \"${ .expressions }\",\n \"iterationParam\": \"singleexpression\",\n \"outputCollection\": \"${ .results }\",\n \"actions\":[\n   {\n      \"functionRef\": {\n         \"refName\": \"solveMathExpressionFunction\",\n         \"arguments\": {\n           \"expression\": \"${ .singleexpression }\"\n         }\n      }\n   }\n ],\n \"stateDataFilter\": {\n    \"output\": \"${ .results }\"\n },\n \"end\": true\n}\n]\n}"
  },
  {
    "input": "This example uses a Parallel State to execute\ntwo branches (simple wait states) at the same time. The completionType\ntype is set to “allOf”, which means the parallel state has to wait for\nboth branches to finish execution before it can transition (end workflow\nexecution in this case as it is an end state).",
    "output": "{\n\"id\": \"parallelexec\",\n\"version\": \"1.0\",\n\"specVersion\": \"0.8\",\n\"name\": \"Parallel Execution Workflow\",\n\"description\": \"Executes two branches in parallel\",\n\"start\": \"ParallelExec\",\n\"states\":[\n  {\n     \"name\": \"ParallelExec\",\n     \"type\": \"parallel\",\n     \"completionType\": \"allOf\",\n     \"branches\": [\n        {\n          \"name\": \"ShortDelayBranch\",\n          \"actions\": [{\n            \"subFlowRef\": \"shortdelayworkflowid\"\n          }]\n        },\n        {\n          \"name\": \"LongDelayBranch\",\n          \"actions\": [{\n            \"subFlowRef\": \"longdelayworkflowid\"\n          }]\n        }\n     ],\n     \"end\": true\n  }\n]\n}"
  },
  {
    "input": "This example uses a Operation State to invoke\na function async. This functions sends an email to a customer. Async\nfunction execution is a “fire-and-forget” type of invocation. The\nfunction is invoked and workflow execution does not wait for its\nresults.",
    "output": "{\n \"id\": \"sendcustomeremail\",\n \"version\": \"1.0\",\n \"specVersion\": \"0.8\",\n \"name\": \"Send customer email workflow\",\n \"description\": \"Send email to a customer\",\n \"start\": \"Send Email\",\n \"functions\": [\n  {\n   \"name\": \"emailFunction\",\n   \"operation\": \"file://myapis/emailapis.json#sendEmail\"\n  }\n ],\n \"states\":[\n  {\n   \"name\":\"Send Email\",\n   \"type\":\"operation\",\n   \"actions\":[\n    {\n     \"functionRef\": {\n      \"invoke\": \"async\",\n      \"refName\": \"emailFunction\",\n      \"arguments\": {\n       \"customer\": \"${ .customer }\"\n      }\n     }\n    }\n   ],\n   \"end\": true\n  }\n ]\n}"
  },
  {
    "input": "This example uses a Operation State to invoke\na SubFlow async. This\nSubFlow is responsible for performing some customer business logic.\nAsync SubFlow invocation is a “fire-and-forget” type of invocation. The\nSubFlow is invoked and workflow execution does not wait for its results.\nIn addition, we specify that the SubFlow should be allowed to continue\nits execution event if the parent workflow completes its own execution.\nThis is done by defining the actions onParentComplete\nproperty to continue.",
    "output": "{\n \"id\": \"onboardcustomer\",\n \"version\": \"1.0\",\n \"specVersion\": \"0.8\",\n \"name\": \"Onboard Customer\",\n \"description\": \"Onboard a Customer\",\n \"start\": \"Onboard\",\n \"states\":[\n  {\n   \"name\":\"Onboard\", \n   \"type\":\"operation\",\n   \"actions\":[\n    {\n     \"subFlowRef\": {\n      \"invoke\": \"async\",\n      \"onParentComplete\": \"continue\",\n      \"workflowId\": \"customeronboardingworkflow\",\n      \"version\": \"1.0\"\n     }\n    }\n   ],\n   \"end\": true\n  }\n ]\n}"
  },
  {
    "input": "In this example we use an Event-based Switch State to wait for\narrival of the “VisaApproved”, or “VisaRejected” Cloud Events. Depending\non which type of event happens, the workflow performs a different\ntransition. If none of the events arrive in the defined 1 hour timeout\nperiod, the workflow transitions to the “HandleNoVisaDecision”\nstate.",
    "output": "{\n\"id\": \"eventbasedswitchstate\",\n\"version\": \"1.0\",\n\"specVersion\": \"0.8\",\n\"name\": \"Event Based Switch Transitions\",\n\"description\": \"Event Based Switch Transitions\",\n\"start\": \"CheckVisaStatus\",\n\"events\": [\n{\n    \"name\": \"visaApprovedEvent\",\n    \"type\": \"VisaApproved\",\n    \"source\": \"visaCheckSource\"\n},\n{\n    \"name\": \"visaRejectedEvent\",\n    \"type\": \"VisaRejected\",\n    \"source\": \"visaCheckSource\"\n}\n],\n\"states\":[\n  {\n     \"name\":\"CheckVisaStatus\",\n     \"type\":\"switch\",\n     \"eventConditions\": [\n        {\n          \"eventRef\": \"visaApprovedEvent\",\n          \"transition\": \"HandleApprovedVisa\"\n        },\n        {\n          \"eventRef\": \"visaRejectedEvent\",\n          \"transition\": \"HandleRejectedVisa\"\n        }\n     ],\n     \"eventTimeout\": \"PT1H\",\n     \"defaultCondition\": {\n        \"transition\": \"HandleNoVisaDecision\"\n     }\n  },\n  {\n    \"name\": \"HandleApprovedVisa\",\n    \"type\": \"operation\",\n    \"actions\": [\n      {\n        \"subFlowRef\": \"handleApprovedVisaWorkflowID\"\n      }\n    ],\n    \"end\": true\n  },\n  {\n      \"name\": \"HandleRejectedVisa\",\n      \"type\": \"operation\",\n      \"actions\": [\n        {\n          \"subFlowRef\": \"handleRejectedVisaWorkflowID\"\n        }\n      ],\n      \"end\": true\n  },\n  {\n      \"name\": \"HandleNoVisaDecision\",\n      \"type\": \"operation\",\n      \"actions\": [\n        {\n          \"subFlowRef\": \"handleNoVisaDecisionWorkflowId\"\n        }\n      ],\n      \"end\": true\n  }\n]\n}"
  },
  {
    "input": "This example shows off the Switch State and the subflow\naction. The workflow is started with application information data as\ninput:",
    "output": "{\n   \"id\": \"applicantrequest\",\n   \"version\": \"1.0\",\n   \"specVersion\": \"0.8\",\n   \"name\": \"Applicant Request Decision Workflow\",\n   \"description\": \"Determine if applicant request is valid\",\n   \"start\": \"CheckApplication\",\n   \"functions\": [\n     {\n        \"name\": \"sendRejectionEmailFunction\",\n        \"operation\": \"http://myapis.org/applicationapi.json#emailRejection\"\n     }\n   ],\n   \"states\":[\n      {\n         \"name\":\"CheckApplication\",\n         \"type\":\"switch\",\n         \"dataConditions\": [\n            {\n              \"condition\": \"${ .applicants | .age >= 18 }\",\n              \"transition\": \"StartApplication\"\n            },\n            {\n              \"condition\": \"${ .applicants | .age < 18 }\",\n              \"transition\": \"RejectApplication\"\n            }\n         ],\n         \"defaultCondition\": {\n            \"transition\": \"RejectApplication\"\n         }\n      },\n      {\n        \"name\": \"StartApplication\",\n        \"type\": \"operation\",\n        \"actions\": [\n          {\n            \"subFlowRef\": \"startApplicationWorkflowId\"\n          }\n        ],\n        \"end\": true\n      },\n      {\n        \"name\":\"RejectApplication\",\n        \"type\":\"operation\",\n        \"actionMode\":\"sequential\",\n        \"actions\":[\n           {\n              \"functionRef\": {\n                 \"refName\": \"sendRejectionEmailFunction\",\n                 \"arguments\": {\n                   \"applicant\": \"${ .applicant }\"\n                 }\n              }\n           }\n        ],\n        \"end\": true\n    }\n   ]\n}"
  },
  {
    "input": "In this example we show off the states error handling capability. The\nworkflow data input that’s passed in contains missing order information\nthat causes the function in the “ProvisionOrder” state to throw a\nruntime exception. With the “onErrors” definition we can transition the\nworkflow to different error handling states. Each type of error in this\nexample is handled by simple delay states. If no errors are encountered\nthe workflow can transition to the “ApplyOrder” state.",
    "output": "{\n\"id\": \"provisionorders\",\n\"version\": \"1.0\",\n\"specVersion\": \"0.8\",\n\"name\": \"Provision Orders\",\n\"description\": \"Provision Orders and handle errors thrown\",\n\"start\": \"ProvisionOrder\",\n\"functions\": [\n  {\n     \"name\": \"provisionOrderFunction\",\n     \"operation\": \"http://myapis.org/provisioningapi.json#doProvision\"\n  }\n],\n\"errors\": [\n {\n  \"name\": \"Missing order id\"\n },\n {\n  \"name\": \"Missing order item\"\n },\n {\n  \"name\": \"Missing order quantity\"\n }\n],\n\"states\":[\n  {\n    \"name\":\"ProvisionOrder\",\n    \"type\":\"operation\",\n    \"actionMode\":\"sequential\",\n    \"actions\":[\n       {\n          \"functionRef\": {\n             \"refName\": \"provisionOrderFunction\",\n             \"arguments\": {\n               \"order\": \"${ .order }\"\n             }\n          }\n       }\n    ],\n    \"stateDataFilter\": {\n       \"output\": \"${ .exceptions }\"\n    },\n    \"transition\": \"ApplyOrder\",\n    \"onErrors\": [\n       {\n         \"errorRef\": \"Missing order id\",\n         \"transition\": \"MissingId\"\n       },\n       {\n         \"errorRef\": \"Missing order item\",\n         \"transition\": \"MissingItem\"\n       },\n       {\n        \"errorRef\": \"Missing order quantity\",\n        \"transition\": \"MissingQuantity\"\n       }\n    ]\n},\n{\n   \"name\": \"MissingId\",\n   \"type\": \"operation\",\n   \"actions\": [\n     {\n       \"subFlowRef\": \"handleMissingIdExceptionWorkflow\"\n     }\n   ],\n   \"end\": true\n},\n{\n   \"name\": \"MissingItem\",\n   \"type\": \"operation\",\n   \"actions\": [\n     {\n       \"subFlowRef\": \"handleMissingItemExceptionWorkflow\"\n     }\n   ],\n   \"end\": true\n},\n{\n   \"name\": \"MissingQuantity\",\n   \"type\": \"operation\",\n   \"actions\": [\n     {\n       \"subFlowRef\": \"handleMissingQuantityExceptionWorkflow\"\n     }\n   ],\n   \"end\": true\n},\n{\n   \"name\": \"ApplyOrder\",\n   \"type\": \"operation\",\n   \"actions\": [\n     {\n       \"subFlowRef\": \"applyOrderWorkflowId\"\n     }\n   ],\n   \"end\": true\n}\n]\n}"
  },
  {
    "input": "In this example we submit a job via an operation state action\n(serverless function call). It is assumed that it takes some time for\nthe submitted job to complete and that it’s completion can be checked\nvia another separate serverless function call.",
    "output": "{\n  \"id\": \"jobmonitoring\",\n  \"version\": \"1.0\",\n  \"specVersion\": \"0.8\",\n  \"name\": \"Job Monitoring\",\n  \"description\": \"Monitor finished execution of a submitted job\",\n  \"start\": \"SubmitJob\",\n  \"functions\": [\n    {\n      \"name\": \"submitJob\",\n      \"operation\": \"http://myapis.org/monitorapi.json#doSubmit\"\n    },\n    {\n      \"name\": \"checkJobStatus\",\n      \"operation\": \"http://myapis.org/monitorapi.json#checkStatus\"\n    },\n    {\n      \"name\": \"reportJobSuceeded\",\n      \"operation\": \"http://myapis.org/monitorapi.json#reportSucceeded\"\n    },\n    {\n      \"name\": \"reportJobFailed\",\n      \"operation\": \"http://myapis.org/monitorapi.json#reportFailure\"\n    }\n  ],\n  \"states\":[\n    {\n      \"name\":\"SubmitJob\",\n      \"type\":\"operation\",\n      \"actionMode\":\"sequential\",\n      \"actions\":[\n      {\n          \"functionRef\": {\n            \"refName\": \"submitJob\",\n            \"arguments\": {\n              \"name\": \"${ .job.name }\"\n            }\n          },\n          \"actionDataFilter\": {\n            \"results\": \"${ .jobuid }\"\n          }\n      }\n      ],\n      \"stateDataFilter\": {\n          \"output\": \"${ .jobuid }\"\n      },\n      \"transition\": \"WaitForCompletion\"\n  },\n  {\n      \"name\": \"WaitForCompletion\",\n      \"type\": \"sleep\",\n      \"duration\": \"PT5S\",\n      \"transition\": \"GetJobStatus\"\n  },\n  {\n      \"name\":\"GetJobStatus\",\n      \"type\":\"operation\",\n      \"actionMode\":\"sequential\",\n      \"actions\":[\n      {\n        \"functionRef\": {\n            \"refName\": \"checkJobStatus\",\n            \"arguments\": {\n              \"name\": \"${ .jobuid }\"\n            }\n          },\n          \"actionDataFilter\": {\n            \"results\": \"${ .jobstatus }\"\n          }\n      }\n      ],\n      \"stateDataFilter\": {\n          \"output\": \"${ .jobstatus }\"\n      },\n      \"transition\": \"DetermineCompletion\"\n  },\n  {\n    \"name\":\"DetermineCompletion\",\n    \"type\":\"switch\",\n    \"dataConditions\": [\n      {\n        \"condition\": \"${ .jobStatus == \\\"SUCCEEDED\\\" }\",\n        \"transition\": \"JobSucceeded\"\n      },\n      {\n        \"condition\": \"${ .jobStatus == \\\"FAILED\\\" }\",\n        \"transition\": \"JobFailed\"\n      }\n    ],\n    \"defaultCondition\": {\n      \"transition\": \"WaitForCompletion\"\n    }\n  },\n  {\n      \"name\":\"JobSucceeded\",\n      \"type\":\"operation\",\n      \"actionMode\":\"sequential\",\n      \"actions\":[\n      {\n        \"functionRef\": {\n            \"refName\": \"reportJobSuceeded\",\n            \"arguments\": {\n              \"name\": \"${ .jobuid }\"\n            }\n        }\n      }\n      ],\n      \"end\": true\n  },\n  {\n    \"name\":\"JobFailed\",\n    \"type\":\"operation\",\n    \"actionMode\":\"sequential\",\n    \"actions\":[\n    {\n        \"functionRef\": {\n          \"refName\": \"reportJobFailed\",\n          \"arguments\": {\n            \"name\": \"${ .jobuid }\"\n          }\n        }\n    }\n    ],\n    \"end\": true\n  }\n  ]\n}"
  },
  {
    "input": "This example shows how we can produce a CloudEvent on completion of a\nworkflow. Let’s say we have the following workflow data containing\norders that need to be provisioned by our workflow:",
    "output": "{\n\"id\": \"sendcloudeventonprovision\",\n\"version\": \"1.0\",\n\"specVersion\": \"0.8\",\n\"name\": \"Send CloudEvent on provision completion\",\n\"start\": \"ProvisionOrdersState\",\n\"events\": [\n{\n    \"name\": \"provisioningCompleteEvent\",\n    \"type\": \"provisionCompleteType\",\n    \"kind\": \"produced\"\n}\n],\n\"functions\": [\n{\n    \"name\": \"provisionOrderFunction\",\n    \"operation\": \"http://myapis.org/provisioning.json#doProvision\"\n}\n],\n\"states\": [\n{\n    \"name\": \"ProvisionOrdersState\",\n    \"type\": \"foreach\",\n    \"inputCollection\": \"${ .orders }\",\n    \"iterationParam\": \"singleorder\",\n    \"outputCollection\": \"${ .provisionedOrders }\",\n    \"actions\": [\n        {\n            \"functionRef\": {\n                \"refName\": \"provisionOrderFunction\",\n                \"arguments\": {\n                    \"order\": \"${ .singleorder }\"\n                }\n            }\n        }\n    ],\n    \"end\": {\n        \"produceEvents\": [{\n            \"eventRef\": \"provisioningCompleteEvent\",\n            \"data\": \"${ .provisionedOrders }\"\n        }]\n    }\n}\n]\n}"
  },
  {
    "input": "In this example a hospital patient is monitored by a Vial Sign\nMonitoring system. This device can produce three different Cloud Events,\nnamely “High Body Temperature”, “High Blood Pressure”, and “High\nRespiration Rate”. Our workflow which needs to take proper actions\ndepending on the event the Vital Sign Monitor produces needs to start if\nany of these events occur. For each of these events a new instance of\nthe workflow is started.",
    "output": "{\n\"id\": \"patientVitalsWorkflow\",\n\"name\": \"Monitor Patient Vitals\",\n\"version\": \"1.0\",\n\"specVersion\": \"0.8\",\n\"start\": \"MonitorVitals\",\n\"events\": [\n{\n    \"name\": \"HighBodyTemperature\",\n    \"type\": \"org.monitor.highBodyTemp\",\n    \"source\": \"monitoringSource\",\n    \"correlation\": [\n      {\n        \"contextAttributeName\": \"patientId\"\n      }\n    ]\n},\n{\n    \"name\": \"HighBloodPressure\",\n    \"type\": \"org.monitor.highBloodPressure\",\n    \"source\": \"monitoringSource\",\n    \"correlation\": [\n      {\n        \"contextAttributeName\": \"patientId\"\n      }\n    ]\n},\n{\n    \"name\": \"HighRespirationRate\",\n    \"type\": \"org.monitor.highRespirationRate\",\n    \"source\": \"monitoringSource\",\n    \"correlation\": [\n      {\n        \"contextAttributeName\": \"patientId\"\n      }\n    ]\n}\n],\n\"functions\": [\n{\n    \"name\": \"callPulmonologist\",\n    \"operation\": \"http://myapis.org/patientapis.json#callPulmonologist\"\n},\n{\n    \"name\": \"sendTylenolOrder\",\n    \"operation\": \"http://myapis.org/patientapis.json#tylenolOrder\"\n},\n{\n    \"name\": \"callNurse\",\n    \"operation\": \"http://myapis.org/patientapis.json#callNurse\"\n}\n],\n\"states\": [\n{\n\"name\": \"MonitorVitals\",\n\"type\": \"event\",\n\"exclusive\": true,\n\"onEvents\": [{\n        \"eventRefs\": [\"HighBodyTemperature\"],\n        \"actions\": [{\n            \"functionRef\": {\n                \"refName\": \"sendTylenolOrder\",\n                \"arguments\": {\n                    \"patientid\": \"${ .patientId }\"\n                }\n            }\n        }]\n    },\n    {\n        \"eventRefs\": [\"HighBloodPressure\"],\n        \"actions\": [{\n            \"functionRef\": {\n                \"refName\": \"callNurse\",\n                \"arguments\": {\n                    \"patientid\": \"${ .patientId }\"\n                }\n            }\n        }]\n    },\n    {\n        \"eventRefs\": [\"HighRespirationRate\"],\n        \"actions\": [{\n            \"functionRef\": {\n                \"refName\": \"callPulmonologist\",\n                \"arguments\": {\n                    \"patientid\": \"${ .patientId }\"\n                }\n            }\n        }]\n    }\n],\n\"end\": {\n    \"terminate\": true\n}\n}]\n}"
  },
  {
    "input": "In this example our workflow is instantiated when all requirements of\na college application are completed. These requirements include a\nstudent submitting an application, the college receiving the students\nSAT scores, as well as a student recommendation letter from a former\nteacher.",
    "output": "{\n\"id\": \"finalizeCollegeApplication\",\n\"name\": \"Finalize College Application\",\n\"version\": \"1.0\",\n\"specVersion\": \"0.8\",\n\"start\": \"FinalizeApplication\",\n\"events\": [\n{\n    \"name\": \"ApplicationSubmitted\",\n    \"type\": \"org.application.submitted\",\n    \"source\": \"applicationsource\",\n    \"correlation\": [\n    {\n      \"contextAttributeName\": \"applicantId\"\n    }\n   ]\n},\n{\n    \"name\": \"SATScoresReceived\",\n    \"type\": \"org.application.satscores\",\n    \"source\": \"applicationsource\",\n    \"correlation\": [\n      {\n      \"contextAttributeName\": \"applicantId\"\n      }\n    ]\n},\n{\n    \"name\": \"RecommendationLetterReceived\",\n    \"type\": \"org.application.recommendationLetter\",\n    \"source\": \"applicationsource\",\n    \"correlation\": [\n      {\n      \"contextAttributeName\": \"applicantId\"\n      }\n    ]\n}\n],\n\"functions\": [\n{\n    \"name\": \"finalizeApplicationFunction\",\n    \"operation\": \"http://myapis.org/collegeapplicationapi.json#finalize\"\n}\n],\n\"states\": [\n{\n    \"name\": \"FinalizeApplication\",\n    \"type\": \"event\",\n    \"exclusive\": false,\n    \"onEvents\": [\n        {\n            \"eventRefs\": [\n                \"ApplicationSubmitted\",\n                \"SATScoresReceived\",\n                \"RecommendationLetterReceived\"\n            ],\n            \"actions\": [\n                {\n                    \"functionRef\": {\n                        \"refName\": \"finalizeApplicationFunction\",\n                        \"arguments\": {\n                            \"student\": \"${ .applicantId }\"\n                        }\n                    }\n                }\n            ]\n        }\n    ],\n    \"end\": {\n        \"terminate\": true\n    }\n}\n]\n}"
  },
  {
    "input": "In this example our serverless workflow needs to integrate with an\nexternal microservice to perform a credit check. We assume that this\nexternal microservice notifies a human actor which has to make the\napproval decision based on customer information. Once this decision is\nmade the service emits a CloudEvent which includes the decision\ninformation as part of its payload. The workflow waits for this callback\nevent and then triggers workflow transitions based on the credit check\ndecision results.",
    "output": "{\n    \"id\": \"customercreditcheck\",\n    \"version\": \"1.0\",\n    \"specVersion\": \"0.8\",\n    \"name\": \"Customer Credit Check Workflow\",\n    \"description\": \"Perform Customer Credit Check\",\n    \"start\": \"CheckCredit\",\n    \"functions\": [\n        {\n            \"name\": \"creditCheckFunction\",\n            \"operation\": \"http://myapis.org/creditcheckapi.json#doCreditCheck\"\n        },\n        {\n            \"name\": \"sendRejectionEmailFunction\",\n            \"operation\": \"http://myapis.org/creditcheckapi.json#rejectionEmail\"\n        }\n    ],\n    \"events\": [\n        {\n            \"name\": \"CreditCheckCompletedEvent\",\n            \"type\": \"creditCheckCompleteType\",\n            \"source\": \"creditCheckSource\",\n            \"correlation\": [\n              {\n                \"contextAttributeName\": \"customerId\"\n              }\n           ]\n        }\n    ],\n    \"states\": [\n        {\n            \"name\": \"CheckCredit\",\n            \"type\": \"callback\",\n            \"action\": {\n                \"functionRef\": {\n                    \"refName\": \"callCreditCheckMicroservice\",\n                    \"arguments\": {\n                        \"customer\": \"${ .customer }\"\n                    }\n                }\n            },\n            \"eventRef\": \"CreditCheckCompletedEvent\",\n            \"timeouts\": {\n              \"stateExecTimeout\": \"PT15M\"\n            },\n            \"transition\": \"EvaluateDecision\"\n        },\n        {\n            \"name\": \"EvaluateDecision\",\n            \"type\": \"switch\",\n            \"dataConditions\": [\n                {\n                    \"condition\": \"${ .creditCheck | .decision == \\\"Approved\\\" }\",\n                    \"transition\": \"StartApplication\"\n                },\n                {\n                    \"condition\": \"${ .creditCheck | .decision == \\\"Denied\\\" }\",\n                    \"transition\": \"RejectApplication\"\n                }\n            ],\n            \"defaultCondition\": {\n               \"transition\": \"RejectApplication\"\n            }\n        },\n        {\n            \"name\": \"StartApplication\",\n            \"type\": \"operation\",\n            \"actions\": [\n              {\n                \"subFlowRef\": \"startApplicationWorkflowId\"\n              }\n            ],\n            \"end\": true\n        },\n        {\n            \"name\": \"RejectApplication\",\n            \"type\": \"operation\",\n            \"actionMode\": \"sequential\",\n            \"actions\": [\n                {\n                    \"functionRef\": {\n                        \"refName\": \"sendRejectionEmailFunction\",\n                        \"arguments\": {\n                            \"applicant\": \"${ .customer }\"\n                        }\n                    }\n                }\n            ],\n            \"end\": true\n        }\n    ]\n}"
  },
  {
    "input": "In this example our serverless workflow needs to handle bits for an\nonline car auction. The car auction has a specific start and end time.\nBids are only allowed to be made during this time period. All bids\nbefore or after this time should not be considered. We assume that the\ncar auction starts at 9am UTC on March 20th 2020 and ends at 3pm UTC on\nMarch 20th 2020.",
    "output": "{\n    \"id\": \"handleCarAuctionBid\",\n    \"version\": \"1.0\",\n    \"specVersion\": \"0.8\",\n    \"name\": \"Car Auction Bidding Workflow\",\n    \"description\": \"Store a single bid whole the car auction is active\",\n    \"start\": {\n      \"stateName\": \"StoreCarAuctionBid\",\n      \"schedule\": \"R/PT2H\"\n    },\n    \"functions\": [\n        {\n            \"name\": \"StoreBidFunction\",\n            \"operation\": \"http://myapis.org/carauctionapi.json#storeBid\"\n        }\n    ],\n    \"events\": [\n        {\n            \"name\": \"CarBidEvent\",\n            \"type\": \"carBidMadeType\",\n            \"source\": \"carBidEventSource\"\n        }\n    ],\n    \"states\": [\n        {\n          \"name\": \"StoreCarAuctionBid\",\n          \"type\": \"event\",\n          \"exclusive\": true,\n          \"onEvents\": [\n            {\n                \"eventRefs\": [\"CarBidEvent\"],\n                \"actions\": [{\n                    \"functionRef\": {\n                        \"refName\": \"StoreBidFunction\",\n                        \"arguments\": {\n                            \"bid\": \"${ .bid }\"\n                        }\n                    }\n                }]\n            }\n          ],\n          \"end\": true\n        }\n    ]\n}"
  },
  {
    "input": "In this example we show the use of scheduled cron-based start event\nproperty. The example workflow checks the users inbox every 15 minutes\nand send them a text message when there are important emails.",
    "output": "{\n\"id\": \"checkInbox\",\n\"name\": \"Check Inbox Workflow\",\n\"version\": \"1.0\",\n\"specVersion\": \"0.8\",\n\"description\": \"Periodically Check Inbox\",\n\"start\": {\n    \"stateName\": \"CheckInbox\",\n    \"schedule\": {\n        \"cron\": \"0 0/15 * * * ?\"\n    }\n},\n\"functions\": [\n    {\n        \"name\": \"checkInboxFunction\",\n        \"operation\": \"http://myapis.org/inboxapi.json#checkNewMessages\"\n    },\n    {\n        \"name\": \"sendTextFunction\",\n        \"operation\": \"http://myapis.org/inboxapi.json#sendText\"\n    }\n],\n\"states\": [\n    {\n        \"name\": \"CheckInbox\",\n        \"type\": \"operation\",\n        \"actionMode\": \"sequential\",\n        \"actions\": [\n            {\n                \"functionRef\": \"checkInboxFunction\"\n            }\n        ],\n        \"transition\": \"SendTextForHighPriority\"\n    },\n    {\n        \"name\": \"SendTextForHighPriority\",\n        \"type\": \"foreach\",\n        \"inputCollection\": \"${ .messages }\",\n        \"iterationParam\": \"singlemessage\",\n        \"actions\": [\n            {\n                \"functionRef\": {\n                    \"refName\": \"sendTextFunction\",\n                    \"arguments\": {\n                        \"message\": \"${ .singlemessage }\"\n                    }\n                }\n            }\n        ],\n        \"end\": true\n    }\n]\n}"
  },
  {
    "input": "In this example we want to make a Veterinary appointment for our dog\nMia. The vet service can be invoked only via an event, and its\ncompletion results with the appointment day and time is returned via an\nevent as well.",
    "output": "{\n    \"id\": \"VetAppointmentWorkflow\",\n    \"name\": \"Vet Appointment Workflow\",\n    \"description\": \"Vet service call via events\",\n    \"version\": \"1.0\",\n    \"specVersion\": \"0.8\",\n    \"start\": \"MakeVetAppointmentState\",\n    \"events\": [\n        {\n            \"name\": \"MakeVetAppointment\",\n            \"source\": \"VetServiceSource\",\n            \"type\": \"events.vet.appointments\",\n            \"kind\": \"produced\"\n        },\n        {\n            \"name\": \"VetAppointmentInfo\",\n            \"source\": \"VetServiceSource\",\n            \"type\": \"events.vet.appointments\",\n            \"kind\": \"consumed\"\n        }\n    ],\n    \"states\": [\n        {\n            \"name\": \"MakeVetAppointmentState\",\n            \"type\": \"operation\",\n            \"actions\": [\n                {\n                    \"name\": \"MakeAppointmentAction\",\n                    \"eventRef\": {\n                       \"triggerEventRef\": \"MakeVetAppointment\",\n                       \"data\": \"${ .patientInfo }\",\n                       \"resultEventRef\":  \"VetAppointmentInfo\"\n                    },\n                    \"actionDataFilter\": {\n                        \"results\": \"${ .appointmentInfo }\"\n                    }\n                }\n            ],\n            \"timeouts\": {\n              \"actionExecTimeout\": \"PT15M\"\n            },\n            \"end\": true\n        }\n    ]\n}"
  },
  {
    "input": "This example shows how function and event definitions can be\ndeclared independently and referenced by workflow definitions. This is\nuseful when you would like to reuse event and function definitions\nacross multiple workflows. In those scenarios it allows you to make\nchanged/updates to these definitions in a single place without having to\nmodify multiple workflows.",
    "output": "{\n  \"id\": \"patientonboarding\",\n  \"name\": \"Patient Onboarding Workflow\",\n  \"version\": \"1.0\",\n  \"specVersion\": \"0.8\",\n  \"start\": \"Onboard\",\n  \"states\": [\n    {\n      \"name\": \"Onboard\",\n      \"type\": \"event\",\n      \"onEvents\": [\n        {\n          \"eventRefs\": [\n            \"NewPatientEvent\"\n          ],\n          \"actions\": [\n            {\n              \"functionRef\": \"StorePatient\",\n              \"retryRef\": \"ServicesNotAvailableRetryStrategy\",\n              \"retryableErrors\": [\"ServiceNotAvailable\"]\n            },\n            {\n              \"functionRef\": \"AssignDoctor\",\n              \"retryRef\": \"ServicesNotAvailableRetryStrategy\",\n              \"retryableErrors\": [\"ServiceNotAvailable\"]\n            },\n            {\n              \"functionRef\": \"ScheduleAppt\",\n              \"retryRef\": \"ServicesNotAvailableRetryStrategy\",\n              \"retryableErrors\": [\"ServiceNotAvailable\"]\n            }\n          ]\n        }\n      ],\n      \"onErrors\": [\n        {\n          \"errorRef\": \"ServiceNotAvailable\",\n          \"end\": true\n        }\n      ],\n      \"end\": true\n    }\n  ],\n  \"events\": [\n    {\n      \"name\": \"StorePatient\",\n      \"type\": \"new.patients.event\",\n      \"source\": \"newpatient/+\"\n    }\n  ],\n  \"functions\": [\n    {\n      \"name\": \"StoreNewPatientInfo\",\n      \"operation\": \"api/services.json#addPatient\"\n    },\n    {\n      \"name\": \"AssignDoctor\",\n      \"operation\": \"api/services.json#assignDoctor\"\n    },\n    {\n      \"name\": \"ScheduleAppt\",\n      \"operation\": \"api/services.json#scheduleAppointment\"\n    }\n  ],\n  \"errors\": [\n   {\n    \"name\": \"ServiceNotAvailable\",\n    \"code\": \"503\"\n   }\n  ],\n  \"retries\": [\n    {\n      \"name\": \"ServicesNotAvailableRetryStrategy\",\n      \"delay\": \"PT3S\",\n      \"maxAttempts\": 10\n    }\n  ]\n}"
  },
  {
    "input": "In this example we want to use a workflow to onboard a new patient\n(at a hospital for example). To onboard a patient our workflow is\ninvoked via a “NewPatientEvent” event. This events payload contains the\npatient information, for example:",
    "output": "{\n  \"id\": \"order\",\n  \"name\": \"Purchase Order Workflow\",\n  \"version\": \"1.0\",\n  \"specVersion\": \"0.8\",\n  \"start\": \"StartNewOrder\",\n  \"timeouts\": {\n    \"workflowExecTimeout\": {\n      \"duration\": \"PT30D\",\n      \"runBefore\": \"CancelOrder\"\n    }\n  },\n  \"states\": [\n    {\n      \"name\": \"StartNewOrder\",\n      \"type\": \"event\",\n      \"onEvents\": [\n        {\n          \"eventRefs\": [\"OrderCreatedEvent\"],\n          \"actions\": [\n            {\n              \"functionRef\": {\n                \"refName\": \"LogNewOrderCreated\"\n              }\n            }\n          ]\n        }\n      ],\n      \"transition\": {\n        \"nextState\": \"WaitForOrderConfirmation\"\n      }\n    },\n    {\n      \"name\": \"WaitForOrderConfirmation\",\n      \"type\": \"event\",\n      \"onEvents\": [\n        {\n          \"eventRefs\": [\"OrderConfirmedEvent\"],\n          \"actions\": [\n            {\n              \"functionRef\": {\n                \"refName\": \"LogOrderConfirmed\"\n              }\n            }\n          ]\n        }\n      ],\n      \"transition\": {\n        \"nextState\": \"WaitOrderShipped\"\n      }\n    },\n    {\n      \"name\": \"WaitOrderShipped\",\n      \"type\": \"event\",\n      \"onEvents\": [\n        {\n          \"eventRefs\": [\"ShipmentSentEvent\"],\n          \"actions\": [\n            {\n              \"functionRef\": {\n                \"refName\": \"LogOrderShipped\"\n              }\n            }\n          ]\n        }\n      ],\n      \"end\": {\n        \"terminate\": true,\n        \"produceEvents\": [\n          {\n            \"eventRef\": \"OrderFinishedEvent\"\n          }\n        ]\n      }\n    },\n    {\n      \"name\": \"CancelOrder\",\n      \"type\": \"operation\",\n      \"actions\": [\n        {\n          \"functionRef\": {\n            \"refName\": \"CancelOrder\"\n          }\n        }\n      ],\n      \"end\": {\n        \"terminate\": true,\n        \"produceEvents\": [\n          {\n            \"eventRef\": \"OrderCancelledEvent\"\n          }\n        ]\n      }\n    }\n  ],\n  \"events\": [\n    {\n      \"name\": \"OrderCreatedEvent\",\n      \"type\": \"my.company.orders\",\n      \"source\": \"/orders/new\",\n      \"correlation\": [\n        {\n          \"contextAttributeName\": \"orderid\"\n        }\n      ]\n    },\n    {\n      \"name\": \"OrderConfirmedEvent\",\n      \"type\": \"my.company.orders\",\n      \"source\": \"/orders/confirmed\",\n      \"correlation\": [\n        {\n          \"contextAttributeName\": \"orderid\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ShipmentSentEvent\",\n      \"type\": \"my.company.orders\",\n      \"source\": \"/orders/shipped\",\n      \"correlation\": [\n        {\n          \"contextAttributeName\": \"orderid\"\n        }\n      ]\n    },\n    {\n      \"name\": \"OrderFinishedEvent\",\n      \"type\": \"my.company.orders\",\n      \"kind\": \"produced\"\n    },\n    {\n      \"name\": \"OrderCancelledEvent\",\n      \"type\": \"my.company.orders\",\n      \"kind\": \"produced\"\n    }\n  ],\n  \"functions\": [\n    {\n      \"name\": \"LogNewOrderCreated\",\n      \"operation\": \"http.myorg.io/ordersservices.json#logcreated\"\n    },\n    {\n      \"name\": \"LogOrderConfirmed\",\n      \"operation\": \"http.myorg.io/ordersservices.json#logconfirmed\"\n    },\n    {\n      \"name\": \"LogOrderShipped\",\n      \"operation\": \"http.myorg.io/ordersservices.json#logshipped\"\n    },\n    {\n      \"name\": \"CancelOrder\",\n      \"operation\": \"http.myorg.io/ordersservices.json#calcelorder\"\n    }\n  ]\n}"
  },
  {
    "input": "In this example our workflow processes purchase orders. An order\nevent triggers instance of our workflow. To complete the created order,\nour workflow must first wait for an order confirmation event (correlated\nto the order id), and then wait for the shipment sent event (also\ncorrelated to initial order id). We do not want to place an exact\ntimeout limit for waiting for the confirmation and shipment events, as\nthis might take a different amount of time depending on the size of the\norder. However we do have the requirement that a total amount of time\nfor the order to be confirmed, once its created, is 30 days. If the\ncreated order is not completed within 30 days it needs to be\nautomatically closed.",
    "output": "{\n  \"id\": \"roomreadings\",\n  \"name\": \"Room Temp and Humidity Workflow\",\n  \"version\": \"1.0\",\n  \"specVersion\": \"0.8\",\n  \"start\": \"ConsumeReading\",\n  \"timeouts\": {\n    \"workflowExecTimeout\": {\n      \"duration\": \"PT1H\",\n      \"runBefore\": \"GenerateReport\"\n    }\n  },\n  \"keepActive\": true,\n  \"states\": [\n    {\n      \"name\": \"ConsumeReading\",\n      \"type\": \"event\",\n      \"onEvents\": [\n        {\n          \"eventRefs\": [\"TemperatureEvent\", \"HumidityEvent\"],\n          \"actions\": [\n            {\n              \"functionRef\": {\n                \"refName\": \"LogReading\"\n              }\n            }\n          ],\n          \"eventDataFilter\": {\n            \"toStateData\": \"${ .readings }\"\n          }\n        }\n      ],\n      \"end\": true\n    },\n    {\n      \"name\": \"GenerateReport\",\n      \"type\": \"operation\",\n      \"actions\": [\n        {\n          \"functionRef\": {\n            \"refName\": \"ProduceReport\",\n            \"arguments\": {\n              \"data\": \"${ .readings }\"\n            }\n          }\n        }\n      ],\n      \"end\": {\n        \"terminate\": true\n      }\n    }\n  ],\n  \"events\": [\n    {\n      \"name\": \"TemperatureEvent\",\n      \"type\": \"my.home.sensors\",\n      \"source\": \"/home/rooms/+\",\n      \"correlation\": [\n        {\n          \"contextAttributeName\": \"roomId\"\n        }\n      ]\n    },\n    {\n      \"name\": \"HumidityEvent\",\n      \"type\": \"my.home.sensors\",\n      \"source\": \"/home/rooms/+\",\n      \"correlation\": [\n        {\n          \"contextAttributeName\": \"roomId\"\n        }\n      ]\n    }\n  ],\n  \"functions\": [\n    {\n      \"name\": \"LogReading\",\n      \"operation\": \"http.myorg.io/ordersservices.json#logreading\"\n    },\n    {\n      \"name\": \"ProduceReport\",\n      \"operation\": \"http.myorg.io/ordersservices.json#produceReport\"\n    }\n  ]\n}"
  },
  {
    "input": "In this example we have two IoT sensors for each room in our house.\nOne reads temperature values and the other humidity values of each room.\nWe get these measurements for each of our rooms as CloudEvents. We can\ncorrelate events send by our sensors by the room it is in.",
    "output": "{\n \"id\": \"checkcarvitals\",\n \"name\": \"Check Car Vitals Workflow\",\n \"version\": \"1.0\",\n \"specVersion\": \"0.8\",\n \"start\": \"WhenCarIsOn\",\n \"states\": [\n  {\n   \"name\": \"WhenCarIsOn\",\n   \"type\": \"event\",\n   \"onEvents\": [\n    {\n     \"eventRefs\": [\"CarTurnedOnEvent\"]\n    }\n   ],\n   \"transition\": \"DoCarVitalChecks\"\n  },\n  {\n   \"name\": \"DoCarVitalChecks\",\n   \"type\": \"operation\",\n   \"actions\": [\n    {\n     \"subFlowRef\": \"vitalscheck\",\n     \"sleep\": {\n      \"after\": \"PT1S\"\n     }\n    }\n   ],\n   \"transition\": \"CheckContinueVitalChecks\"\n  },\n  {\n   \"name\": \"CheckContinueVitalChecks\",\n   \"type\": \"switch\",\n   \"eventConditions\": [\n    {\n     \"name\": \"Car Turned Off Condition\",\n     \"eventRef\": \"CarTurnedOffEvent\",\n     \"end\": true\n    }\n   ],\n   \"defaultCondition\": {\n    \"transition\": \"DoCarVitalChecks\"\n   }\n  }\n ],\n \"events\": [\n  {\n   \"name\": \"CarTurnedOnEvent\",\n   \"type\": \"car.events\",\n   \"source\": \"my/car\"\n  },\n  {\n   \"name\": \"CarTurnedOffEvent\",\n   \"type\": \"car.events\",\n   \"source\": \"my/car\"\n  }\n ]\n}"
  },
  {
    "input": "In this example we need to check car vital signs while our car is\ndriving. The workflow should start when we receive the\n“CarTurnedOnEvent” event and stop when the “CarTurnedOffEvent” event is\nconsumed. While the car is driving our workflow should repeatedly check\nthe vitals every 1 second.",
    "output": "{\n \"id\": \"booklending\",\n \"name\": \"Book Lending Workflow\",\n \"version\": \"1.0\",\n \"specVersion\": \"0.8\",\n \"start\": \"Book Lending Request\",\n \"states\": [\n  {\n   \"name\": \"Book Lending Request\",\n   \"type\": \"event\",\n   \"onEvents\": [\n    {\n     \"eventRefs\": [\"Book Lending Request Event\"]\n    }\n   ],\n   \"transition\": \"Get Book Status\"\n  },\n  {\n   \"name\": \"Get Book Status\",\n   \"type\": \"operation\",\n   \"actions\": [\n    {\n     \"functionRef\": {\n      \"refName\": \"Get status for book\",\n      \"arguments\": {\n       \"bookid\": \"${ .book.id }\"\n      }\n     }\n    }\n   ],\n   \"transition\": \"Book Status Decision\"\n  },\n  {\n   \"name\": \"Book Status Decision\",\n   \"type\": \"switch\",\n   \"dataConditions\": [\n    {\n     \"name\": \"Book is on loan\",\n     \"condition\": \"${ .book.status == \\\"onloan\\\" }\",\n     \"transition\": \"Report Status To Lender\"\n    },\n    {\n     \"name\": \"Check is available\",\n     \"condition\": \"${ .book.status == \\\"available\\\" }\",\n     \"transition\": \"Check Out Book\"\n    }\n   ],\n   \"defaultCondition\": {\n    \"end\": true\n   }\n  },\n  {\n   \"name\": \"Report Status To Lender\",\n   \"type\": \"operation\",\n   \"actions\": [\n    {\n     \"functionRef\": {\n      \"refName\": \"Send status to lender\",\n      \"arguments\": {\n       \"bookid\": \"${ .book.id }\",\n       \"message\": \"Book ${ .book.title } is already on loan\"\n      }\n     }\n    }\n   ],\n   \"transition\": \"Wait for Lender response\"\n  },\n  {\n   \"name\": \"Wait for Lender response\",\n   \"type\": \"switch\",\n   \"eventConditions\": [\n    {\n     \"name\": \"Hold Book\",\n     \"eventRef\": \"Hold Book Event\",\n     \"transition\": \"Request Hold\"\n    },\n    {\n     \"name\": \"Decline Book Hold\",\n     \"eventRef\": \"Decline Hold Event\",\n     \"transition\": \"Cancel Request\"\n    }\n   ],\n   \"defaultCondition\": {\n    \"end\": true\n   }\n  },\n  {\n   \"name\": \"Request Hold\",\n   \"type\": \"operation\",\n   \"actions\": [\n    {\n     \"functionRef\": {\n      \"refName\": \"Request hold for lender\",\n      \"arguments\": {\n       \"bookid\": \"${ .book.id }\",\n       \"lender\": \"${ .lender }\"\n      }\n     }\n    }\n   ],\n   \"transition\": \"Sleep two weeks\"\n  },\n  {\n   \"name\": \"Sleep two weeks\",\n   \"type\": \"sleep\",\n   \"duration\": \"PT2W\",\n   \"transition\": \"Get Book Status\"\n  },\n  {\n   \"name\": \"Check Out Book\",\n   \"type\": \"operation\",\n   \"actions\": [\n    {\n     \"functionRef\": {\n      \"refName\": \"Check out book with id\",\n      \"arguments\": {\n       \"bookid\": \"${ .book.id }\"\n      }\n     }\n    },\n    {\n     \"functionRef\": {\n      \"refName\": \"Notify Lender for checkout\",\n      \"arguments\": {\n       \"bookid\": \"${ .book.id }\",\n       \"lender\": \"${ .lender }\"\n      }\n     }\n    }\n   ],\n   \"end\": true\n  }\n ],\n \"functions\": \"file://books/lending/functions.json\",\n \"events\": \"file://books/lending/events.json\"\n}"
  },
  {
    "input": "In this example we want to create a book lending workflow. The\nworkflow starts when a lender submits a book lending request (via event\n“Book Lending Request Event”). The workflow describes our business logic\naround lending a book, from checking its current availability, to\nwaiting on the lender’s response if the book is currently not available,\nto checking out the book and notifying the lender.",
    "output": "{\n \"id\": \"fillglassofwater\",\n \"name\": \"Fill glass of water workflow\",\n \"version\": \"1.0\",\n \"specVersion\": \"0.8\",\n \"start\": \"Check if full\",\n \"functions\": [\n  {\n   \"name\": \"Increment Current Count Function\",\n   \"type\": \"expression\",\n   \"operation\": \".counts.current += 1 | .counts.current\"\n  }\n ],\n \"states\": [\n  {\n   \"name\": \"Check if full\",\n   \"type\": \"switch\",\n   \"dataConditions\": [\n    {\n     \"name\": \"Need to fill more\",\n     \"condition\": \"${ .counts.current < .counts.max }\",\n     \"transition\": \"Add Water\"\n    },\n    {\n     \"name\": \"Glass full\",\n     \"condition\": \".counts.current >= .counts.max\",\n     \"end\": true\n    }\n   ],\n   \"defaultCondition\": {\n    \"end\": true\n   }\n  },\n  {\n   \"name\": \"Add Water\",\n   \"type\": \"operation\",\n   \"actions\": [\n    {\n     \"functionRef\": \"Increment Current Count Function\",\n     \"actionDataFilter\": {\n      \"toStateData\": \".counts.current\"\n     }\n    }\n   ],\n   \"transition\": \"Check if full\"\n  }\n ]\n}"
  },
  {
    "input": "In this example we showcase the power of expression\nfunctions. Our workflow definition is assumed to have the following\ndata input:",
    "output": "{\n \"id\":\"notifycustomerworkflow\",\n \"name\":\"Notify Customer\",\n \"version\":\"1.0\",\n \"specVersion\": \"0.8\",\n \"start\":\"WaitForCustomerEvent\",\n \"states\":[\n  {\n   \"name\":\"WaitForCustomerEvent\",\n   \"type\":\"event\",\n   \"onEvents\":[\n    {\n     \"eventRefs\":[\n      \"CustomerEvent\"\n     ],\n     \"eventDataFilter\":{\n      \"data\":\"${ .customerId }\",\n      \"toStateData\":\"${ .eventCustomerId }\"\n     },\n     \"actions\":[\n      {\n       \"functionRef\":{\n        \"refName\":\"NotifyCustomerFunction\",\n        \"arguments\":{\n         \"customerId\":\"${ .eventCustomerId }\"\n        }\n       }\n      }\n     ]\n    }\n   ],\n   \"stateDataFilter\":{\n    \"output\":\"${ .count = .count + 1 }\"\n   },\n   \"transition\":\"CheckEventQuota\"\n  },\n  {\n   \"name\":\"CheckEventQuota\",\n   \"type\":\"switch\",\n   \"dataConditions\":[\n    {\n     \"condition\":\"${ try(.customerCount) != null and .customerCount > .quota.maxConsumedEvents }\",\n     \"end\":{\n      \"continueAs\": {\n       \"workflowId\": \"notifycustomerworkflow\",\n       \"version\": \"1.0\",\n       \"data\": \"${ del(.customerCount) }\"\n      }\n     }\n    }\n   ],\n   \"defaultCondition\":{\n    \"transition\":\"WaitForCustomerEvent\"\n   }\n  }\n ],\n \"events\":[\n  {\n   \"name\":\"CustomerEvent\",\n   \"type\":\"org.events.customerEvent\",\n   \"source\":\"customerSource\"\n  }\n ],\n \"functions\":[\n  {\n   \"name\":\"NotifyCustomerFunction\",\n   \"operation\":\"http://myapis.org/customerapis.json#notifyCustomer\"\n  }\n ]\n}"
  },
  {
    "input": "In this example we want to create an online food ordering workflow.\nThe below image outlines the workflow structure and the available\nservices:",
    "output": "{\n \"id\": \"customerbankingtransactions\",\n \"name\": \"Customer Banking Transactions Workflow\",\n \"version\": \"1.0\",\n \"specVersion\": \"0.8\",\n \"autoRetries\": true,\n \"constants\": {\n  \"largetxamount\" : 5000\n },\n \"states\": [\n  {\n   \"name\": \"ProcessTransactions\",\n   \"type\": \"foreach\",\n   \"inputCollection\": \"${ .customer.transactions }\",\n   \"iterationParam\": \"${ .tx }\",\n   \"actions\": [\n    {\n     \"name\": \"Process Larger Transaction\",\n     \"functionRef\": \"Banking Service - Larger Tx\",\n     \"condition\": \"${ .tx >= $CONST.largetxamount }\"\n    },\n    {\n     \"name\": \"Process Smaller Transaction\",\n     \"functionRef\": \"Banking Service - Smaller Tx\",\n     \"condition\": \"${ .tx < $CONST.largetxamount }\"\n    }\n   ],\n   \"end\": true\n  }\n ],\n \"functions\": [\n  {\n   \"name\": \"Banking Service - Larger Tx\",\n   \"type\": \"asyncapi\",\n   \"operation\": \"banking.yaml#largerTransation\"\n  },\n  {\n   \"name\": \"Banking Service - Smaller T\",\n   \"type\": \"asyncapi\",\n   \"operation\": \"banking.yaml#smallerTransation\"\n  }\n ]\n}"
  }
]
